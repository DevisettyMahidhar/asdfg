# Implementation of Symtable using Linked List and Hash Table

This project implements a symbol table using different approaches like linked list and hash table data structures.


## Functions

### SymTable_new
- Allocates memory for the symbol table.

### SymTable_getLength
- Returns the length of the linked list.

### SymTable_free
- Deletes the memory allocated for the symbol table.

### SymTable_get
- If the key is present in the symbol table, return the corresponding value; otherwise, return a null pointer.

### SymTable_contains
- Returns 1 if the key is present in the linked list; otherwise, return 0.

### SymTable_put
- Checks if the key is present. If not found, creates a new node with the respective key and value and returns 1; otherwise, returns 0.

### SymTable_map
- Applies a given function to each node in the symbol table, passing additional data.

### SymTable_remove
- If the provided key is present in the linked list, deletes the node and returns the value it holds; otherwise, returns null.

### SymTable_replace
- If the key is present in the linked list, replaces the old value with the new value and returns the old value; otherwise, returns null

We have chosen to implement the symbol table using a hash table due to its superior efficiency over a linked list. By employing a hash function, we generate keys that determine the index where nodes are stored within the table. This strategy streamlines access to elements as we can directly locate items by their respective indices, resulting in significant time savings.

## Rehash Function

The rehash function is used to increase the size of the symbol table when necessary. We fix a predefined length for the symbol table, for example, 10. As keys are added to the symbol table, if the length of the table exceeds the predefined limit (e.g., 10), the rehash function is called. This function increases the size of the symbol table and returns it.

The sizes of the symbol table typically follow a sequence such as: {509, 1021, 2039, 4093, 8191, 16381, 32749, 65521}. If the number of keys exceeds the current size of the table (e.g., 509), the rehash function is called. It creates a new symbol table with a larger size, for example, 1021. This process continues, increasing the size further as needed. However, if the length reaches more than 65521, the rehash function returns, and the keys are stored at the particular index value generated by the hash function.

## Makefile

The project is implemented using a Makefile for easy compilation and execution.

To compile the project and generate object files, simply type the following command:

```bash
make
```
To run the linked list implementation, execute the following command:
``` bash
./link
```
To run the hash table implementation, execute the following command:
```bash
./hash
```

## valgrind
valgrind is a powerful tool to use to ensure there are no memory leaks within the code.
To run the linked list implementation with valgrind, execute the following command:
``` bash
valgrind ./link
```
To run the hash table implementation with valgrind, execute the following command:
```bash
valgrind ./hash
```

## time exection 
To run the linked list implementation taken time:8.693054 seconds
To run the hash tabel implementation taken time:0.470121 seconds



